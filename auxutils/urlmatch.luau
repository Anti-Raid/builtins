-- Code initially generated by Gemini

--[[
    Parses a URL string into its basic components: scheme, domain, and path.
    This is a simplified parser for the purpose of the url_match function.

    @param url_str The string of the URL to parse.
    @return A table with {scheme, netloc, path} or nil if parsing fails.
]]
local function parseUrl(url_str): { scheme: string, domain: string, path: string }?
    -- Find the scheme (e.g., "https")
    local scheme_end = string.find(url_str, "://")
    if not scheme_end then 
        -- Pretend its https and try again
        return parseUrl("https://" .. url_str)
    end
    local scheme = string.sub(url_str, 1, scheme_end - 1)

    -- Find the netloc (e.g., "google.com")
    local domain_start = scheme_end + 3
    local path_start = string.find(url_str, "/", domain_start)
    local domain
    local path

    if path_start then
        domain = string.sub(url_str, domain_start, path_start - 1)
        path = string.sub(url_str, path_start)
    else
        -- No path found after the domain
        domain = string.sub(url_str, domain_start)
        path = "/"
    end
    
    -- Remove query parameters and fragments from the path for our matching logic
    local query_pos = string.find(path, "?")
    if query_pos then
        path = string.sub(path, 1, query_pos - 1)
    end
    
    local fragment_pos = string.find(path, "#")
    if fragment_pos then
        path = string.sub(path, 1, fragment_pos - 1)
    end

    return { scheme = scheme, domain = domain, path = path }
end

--[[
    Checks if two URLs match based on the described logic.

    A match occurs if the scheme and domain are identical, and the path of the
    first URL is a sub-path of the second.

    @param url1_str The first URL string.
    @param url2_str The second URL string to match against.
    @return True if the URLs match, false otherwise.
]]
function url_match(url1_str, url2_str)
    local parsed_url1 = parseUrl(url1_str)
    local parsed_url2 = parseUrl(url2_str)

    -- If either URL is malformed, they can't match.
    if not parsed_url1 or not parsed_url2 then
        return false
    end

    if parsed_url1.domain ~= parsed_url2.domain then
        return false
    end

    -- 2. Normalize paths to ensure they end with a slash for consistent prefix matching.
    -- This helps handle cases like "/blah" and "/blah/" as equivalent prefixes.
    local path1 = parsed_url1.path
    if string.sub(path1, -1) ~= "/" then
        path1 = path1 .. "/"
    end

    local path2 = parsed_url2.path
    if string.sub(path2, -1) ~= "/" then
        path2 = path2 .. "/"
    end
    
    -- 3. Check if the normalized path1 starts with the normalized path2.
    -- string.sub(s, 1, n) gets the prefix of length n from string s.
    if string.sub(path1, 1, #path2) == path2 then
        return true
    else
        return false
    end
end

assert(url_match('https://google.com', 'https://google.com'), "URL match failed [0]")
assert(url_match('https://google.com/', 'https://google.com'), "URL match failed [1]")
assert(url_match('https://google.com/blah', 'https://google.com'), "URL match failed [2]")
assert(url_match('https://google.com/blah/foo?query=x', 'https://google.com'), "URL match failed [3]")
assert(url_match('https://google.com/blah/foo?query=x', 'https://google.com/blah'), "URL match failed [4]")
assert(not url_match('https://google.com/', 'https://youtube.com'), "URL match failed [5]")
assert(not url_match('https://google.com/foo', 'https://google.com/bar'), "URL match failed [6]")
assert(url_match('http://google.com', 'https://google.com'), "URL match failed [7]")
assert(url_match('google.com', 'https://google.com'), "URL match failed [8]")
assert(not url_match('https://google.com', 'https://google.com/blah'), "URL match failed [8]")

return {
    url_match = url_match
}